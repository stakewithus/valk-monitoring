{"version":3,"sources":["../../src/common/http_client.js"],"names":["logger","child","module","HttpError","ctx","err","Error","wrapReply","uri","reply","statusCode","rawBody","body","validStatusCode","respBody","JSON","parse","warn","rawRequest","nodeIP","nodePort","reqArgs","nodeEndpoint","nodeMethod","qs","timeout","reqHeaders","headers","qString","querystring","encode","fPath","reqOpts","host","port","path","method","resolve","reject","contentStr","contentLen","validDataHeader","length","req","http","request","res","setEncoding","on","chunk","abort","error","info","write","end"],"mappings":"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","file":"http_client.js","sourcesContent":["import http from 'http';\nimport querystring from 'querystring';\nimport pino from 'pino';\n\nconst logger = pino().child({ module: 'common/http_client' });\n\nconst HttpError = (ctx) => {\n  const err = new Error();\n  Object.assign(err, ctx);\n  return err;\n};\n\nconst wrapReply = (uri) => (reply) => {\n  const { statusCode, body: rawBody } = reply;\n  // TODO Make this neater\n  // console.log(`statusCode: ${statusCode}`);\n  // console.log(`body: ${rawBody}`);\n  const validStatusCode = statusCode === 200 || statusCode === 429 || statusCode === 503;\n  if (!validStatusCode) throw HttpError({ statusCode, respBody: rawBody, uri });\n  let body = '';\n  try {\n    body = rawBody && JSON.parse(rawBody);\n  } catch (err) {\n    logger.warn('Unable to parse json!');\n    body = rawBody;\n  }\n  return body;\n};\n\nconst rawRequest = (nodeIP, nodePort, reqArgs) => (nodeEndpoint, nodeMethod = 'GET') => ({ body = {}, qs = {}, timeout }) => {\n  const {\n    headers: reqHeaders,\n  } = reqArgs;\n  const qString = querystring.encode(qs);\n  let fPath = `${nodeEndpoint}`;\n  if (qString !== '') {\n    fPath = `${fPath}?${qString}`;\n  }\n\n  let reqOpts = {\n    host: nodeIP,\n    port: nodePort,\n    path: fPath,\n    method: nodeMethod,\n    headers: {\n      'content-type': 'application/json',\n      ...reqHeaders,\n    },\n  };\n  if (timeout) {\n    reqOpts.timeout = timeout;\n  }\n  return new Promise((resolve, reject) => {\n    let contentStr = '';\n    let contentLen = 0;\n    const validDataHeader = nodeMethod === 'POST' || nodeMethod === 'PUT';\n    if (validDataHeader && Object.keys(body).length > 0) {\n      contentStr = JSON.stringify(body);\n      contentLen = contentStr.length;\n      reqOpts = { ...reqOpts, 'content-length': contentLen };\n    }\n    const req = http.request(reqOpts, (res) => {\n      const { statusCode } = res;\n      res.setEncoding('utf-8');\n      let respBody = '';\n      res.on('data', (chunk) => { respBody += chunk; });\n      res.on('end', () => {\n        try {\n          resolve(wrapReply(nodeEndpoint)({ body: respBody, statusCode }));\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n    req.on('timeout', () => {\n      req.abort();\n    });\n    req.on('error', (err) => {\n      if (err) {\n        logger.error(err);\n        logger.info(reqOpts);\n      }\n      reject(err);\n    });\n    if (contentLen > 0) {\n      req.write(contentStr);\n    }\n    req.end();\n  });\n};\n\nexport default rawRequest;\n"]}